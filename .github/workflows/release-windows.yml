name: Release Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.2)'
        required: true
        type: string

jobs:
  build-windows:
    runs-on: windows-latest
    strategy:
      matrix:
        build_type: [Release, Debug]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install MinGW and Ninja
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-ninja
      
      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.7.3'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw'
          cache: true
          setup-python: false
      
      - name: Configure and Build
        shell: msys2 {0}
        run: |
          mkdir -p build
          cd build
          
          echo "=== Build Configuration ==="
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Qt Root: ${QT_ROOT_DIR}"
          echo "GCC Version:"
          gcc --version
          echo "Ninja Version:"
          ninja --version
          echo ""
          
          echo "Configuring with CMake..."
          cmake .. -G "Ninja" \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
            -DCMAKE_PREFIX_PATH="${QT_ROOT_DIR}" \
            -DSKIP_WINDEPLOYQT_BUILD=ON \
            -DCMAKE_VERBOSE_MAKEFILE=ON
          
          echo ""
          echo "Building BGACore first..."
          cmake --build . --target BGACore --parallel
          if [ $? -ne 0 ]; then
            echo "✗ BGACore build FAILED"
            echo "Printing build tree for diagnostics..."
            find . -type f | head -n 100
            exit 1
          fi
          
          echo ""
          echo "Verifying BGACore output..."
          if [ -f "BGA/libBGACore.dll" ]; then
            echo "✓ Found libBGACore.dll"
            ls -lh BGA/libBGACore.dll
          else
            echo "✗ ERROR: libBGACore.dll not found"
            echo "Searching for BGACore library files..."
            find . -name "*BGACore*" -type f
            exit 1
          fi
          
          echo ""
          echo "Building remaining targets..."
          cmake --build . --parallel
          
          echo ""
          echo "✓ Build completed successfully"
      
      - name: Verify Build Output
        shell: msys2 {0}
        run: |
          echo "=== Verifying build output ==="
          
          if [ -f "build/NST.exe" ]; then
            size=$(stat -c%s "build/NST.exe")
            echo "✓ NST.exe found ($size bytes)"
            ls -lh build/NST.exe
          else
            echo "✗ ERROR: NST.exe not found"
            echo "Searching for NST.exe..."
            find build -name "NST.exe" -type f
            exit 1
          fi
          
          echo ""
          echo "=== Checking DLLs in build folder ==="
          required_dlls="libBGACore.dll QtLingo.dll"
          
          for dll in $required_dlls; do
            found=$(find build -name "$dll" -type f)
            if [ -n "$found" ]; then
              echo "✓ $dll found at: $found"
            else
              echo "⚠ WARNING: $dll not found"
            fi
          done
          
          echo ""
          echo "=== All DLLs in build folder ==="
          find build -name "*.dll" -type f | while read f; do
            echo "  $(basename $f) - $(stat -c%s $f) bytes"
          done

      - name: Deploy Qt dependencies
        shell: pwsh
        run: |
          $exePath = "build\NST.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "✗ ERROR: NST.exe not found at $exePath"
            exit 1
          }

          # Verify Qt environment
          Write-Host "QT_ROOT_DIR: $env:QT_ROOT_DIR"
          Write-Host "QT_PLUGIN_PATH: $env:QT_PLUGIN_PATH"
          
          # Check critical platform plugin
          $platformPlugin = "$env:QT_ROOT_DIR\plugins\platforms\qwindowsd.dll"
          if ("${{ matrix.build_type }}" -eq "Release") {
            $platformPlugin = "$env:QT_ROOT_DIR\plugins\platforms\qwindows.dll"
          }
          
          Write-Host ""
          Write-Host "Checking platform plugin..."
          if (Test-Path $platformPlugin) {
            Write-Host "✓ Found: $platformPlugin"
          } else {
            Write-Host "✗ ERROR: Platform plugin not found: $platformPlugin"
            Write-Host ""
            Write-Host "Contents of platforms directory:"
            if (Test-Path "$env:QT_ROOT_DIR\plugins\platforms") {
              Get-ChildItem "$env:QT_ROOT_DIR\plugins\platforms" | Select-Object Name, Length | Format-Table
            } else {
              Write-Host "Platforms directory doesn't exist!"
            }
            exit 1
          }
          
          # Use QT_ROOT_DIR environment variable set by install-qt-action
          $qtBin = Join-Path $env:QT_ROOT_DIR "bin\windeployqt.exe"
          
          if (-not (Test-Path $qtBin)) {
            Write-Host "✗ ERROR: Could not find windeployqt.exe at $qtBin"
            exit 1
          }

          Write-Host ""
          Write-Host "Running windeployqt from: $qtBin"
          
          # Set Qt plugin path explicitly for windeployqt
          $env:QT_PLUGIN_PATH = "$env:QT_ROOT_DIR\plugins"
          
          if ("${{ matrix.build_type }}" -eq "Debug") {
            Write-Host "Deploying in DEBUG mode"
            & $qtBin --debug --compiler-runtime --no-opengl-sw --verbose 1 $exePath
          } else {
            Write-Host "Deploying in RELEASE mode"
            & $qtBin --release --compiler-runtime --no-opengl-sw --verbose 1 $exePath
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host ""
            Write-Host "✗ ERROR: windeployqt failed with exit code $LASTEXITCODE"
            Write-Host ""
            Write-Host "Attempting manual deployment..."
            
            # Manually copy essential DLLs
            $qtBinDir = "$env:QT_ROOT_DIR\bin"
            $buildDir = "build"
            
            Write-Host "Copying Qt DLLs..."
            $qtDlls = @(
              "Qt6Core.dll",
              "Qt6Gui.dll", 
              "Qt6Widgets.dll",
              "Qt6Network.dll",
              "Qt6Concurrent.dll"
            )
            
            if ("${{ matrix.build_type }}" -eq "Debug") {
              $qtDlls = $qtDlls | ForEach-Object { $_.Replace(".dll", "d.dll") }
            }
            
            foreach ($dll in $qtDlls) {
              $src = Join-Path $qtBinDir $dll
              if (Test-Path $src) {
                Copy-Item $src $buildDir -Force
                Write-Host "  ✓ Copied $dll"
              } else {
                Write-Host "  ⚠ $dll not found, trying without 'd' suffix..."
                $dllNoD = $dll.Replace("d.dll", ".dll")
                $src = Join-Path $qtBinDir $dllNoD
                if (Test-Path $src) {
                  Copy-Item $src $buildDir -Force
                  Write-Host "  ✓ Copied $dllNoD"
                }
              }
            }
            
            # Copy platform plugin
            Write-Host "Copying platform plugins..."
            $platformsDir = Join-Path $buildDir "platforms"
            New-Item -ItemType Directory -Path $platformsDir -Force | Out-Null
            
            $platformSrc = "$env:QT_ROOT_DIR\plugins\platforms\qwindows.dll"
            if ("${{ matrix.build_type }}" -eq "Debug") {
              $platformSrc = "$env:QT_ROOT_DIR\plugins\platforms\qwindowsd.dll"
            }
            
            if (Test-Path $platformSrc) {
              Copy-Item $platformSrc $platformsDir -Force
              Write-Host "  ✓ Copied platform plugin"
            } else {
              # Try without 'd' suffix
              $platformSrc = "$env:QT_ROOT_DIR\plugins\platforms\qwindows.dll"
              if (Test-Path $platformSrc) {
                Copy-Item $platformSrc $platformsDir -Force
                Write-Host "  ✓ Copied platform plugin (release version)"
              }
            }
            
            # Copy styles plugin
            Write-Host "Copying style plugins..."
            $stylesDir = Join-Path $buildDir "styles"
            New-Item -ItemType Directory -Path $stylesDir -Force | Out-Null
            
            Get-ChildItem "$env:QT_ROOT_DIR\plugins\styles" -Filter "*.dll" | ForEach-Object {
              Copy-Item $_.FullName $stylesDir -Force
              Write-Host "  ✓ Copied $($_.Name)"
            }
            
            Write-Host ""
            Write-Host "✓ Manual deployment completed"
          } else {
            Write-Host ""
            Write-Host "✓ windeployqt completed successfully"
          }
          
          Write-Host ""
          Write-Host "Deployed files in build directory:"
          Get-ChildItem "build" -Filter "*.dll" | Select-Object Name, Length | Format-Table

      - name: Package
        shell: msys2 {0}
        run: |
          cd build
          
          # Set package name based on build type
          if [ "${{ matrix.build_type }}" = "Debug" ]; then
            export CPACK_PACKAGE_FILE_NAME="NST-Debug"
          fi
          
          cpack -G ZIP -C ${{ matrix.build_type }}
      
      - name: Verify Package
        shell: pwsh
        run: |
          Write-Host "=== Verifying package ==="
          $buildType = "${{ matrix.build_type }}"
          $packagePattern = if ($buildType -eq "Debug") { "NST-Debug*.zip" } else { "NST-*.zip" }
          $packageFile = Get-ChildItem -Path build -Filter $packagePattern | Select-Object -First 1
          
          if ($packageFile) {
            Write-Host "Package: $($packageFile.Name) ($('{0:N2}' -f ($packageFile.Length / 1MB)) MB)"
            Write-Host "Build Type: $buildType"
            
            Write-Host ""
            Write-Host "Extracting to verify contents..."
            $tempDir = "build\temp_verify"
            Expand-Archive -Path $packageFile.FullName -DestinationPath $tempDir -Force
            
            Write-Host ""
            Write-Host "Package contents:"
            Get-ChildItem -Path $tempDir -Recurse | ForEach-Object { 
              $relativePath = $_.FullName.Substring($tempDir.Length)
              $size = if ($_.PSIsContainer) { "DIR" } else { "{0:N0} bytes" -f $_.Length }
              Write-Host "  $relativePath ($size)"
            }
            
            Remove-Item -Path $tempDir -Recurse -Force
          } else {
            Write-Host "✗ ERROR: No package file found matching: $packagePattern"
            Write-Host "Files in build directory:"
            Get-ChildItem -Path build -Filter "*.zip" | ForEach-Object {
              Write-Host "  $($_.Name)"
            }
            exit 1
          }
      
      - name: Find package file
        id: find_files
        shell: bash
        run: |
          cd build
          if [ "${{ matrix.build_type }}" = "Debug" ]; then
            PACKAGE_FILE=$(ls NST-Debug*.zip 2>/dev/null | head -n 1 || true)
          else
            PACKAGE_FILE=$(ls NST-*.zip 2>/dev/null | grep -v Debug | head -n 1 || true)
          fi
          echo "package_file=$PACKAGE_FILE" >> $GITHUB_OUTPUT
          if [ -n "$PACKAGE_FILE" ]; then
            echo "Found package: $PACKAGE_FILE"
          else
            echo "Error: No package found"
            exit 1
          fi
      
      - name: Upload artifact
        if: steps.find_files.outputs.package_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: nst-windows-${{ matrix.build_type }}
          path: build/${{ steps.find_files.outputs.package_file }}
          retention-days: 1

  release-windows:
    needs: build-windows
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Release artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows-Release
          path: artifacts
      
      - name: Download Debug artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows-Debug
          path: artifacts
      
      - name: Set version tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "tag=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.version.outputs.tag }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${REPO}"
          
          # Get or create release
          resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${API}/releases/tags/${TAG}" || true)
          release_id=$(echo "$resp" | jq -r '.id // empty')
          
          if [ -z "$release_id" ]; then
            echo "Creating release for ${TAG}"
            create_resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
              -d "$(jq -n --arg t "$TAG" --arg n "Release $TAG" '{ tag_name: $t, name: $n }')" \
              "${API}/releases")
            release_id=$(echo "$create_resp" | jq -r '.id')
          fi
          
          # Upload artifacts
          for f in artifacts/*; do
            [ -f "$f" ] || continue
            name=$(basename "$f")
            echo "Uploading $name"
            curl -s -X POST \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Content-Type: application/zip" \
              --data-binary @"$f" \
              "https://uploads.github.com/repos/${REPO}/releases/${release_id}/assets?name=$name"
          done
          
          echo "✓ Upload completed"
          echo "Release URL: https://github.com/${REPO}/releases/tag/${TAG}"
