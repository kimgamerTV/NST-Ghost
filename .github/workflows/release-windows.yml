name: Release Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.2)'
        required: true
        type: string

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.7.3'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw'
          cache: true
          setup-python: false
      
      - name: Configure and Build
        shell: pwsh
        run: |
          if (!(Test-Path -Path 'build')) {
            New-Item -ItemType Directory -Path 'build' | Out-Null
          }
          Set-Location -Path build
          
          # Use MinGW from Qt installation
          $mingwPath = Join-Path $env:QT_ROOT_DIR "bin"
          $env:PATH = "$mingwPath;$env:PATH"
          
          Write-Host "Using MinGW from: $mingwPath"
          Write-Host "g++ version:"
          & "$mingwPath\g++.exe" --version
          
          # MinGW requires explicit generator and compiler paths
          cmake .. -G "MinGW Makefiles" `
            -DCMAKE_C_COMPILER="$mingwPath\gcc.exe" `
            -DCMAKE_CXX_COMPILER="$mingwPath\g++.exe" `
            -DCMAKE_MAKE_PROGRAM="$mingwPath\mingw32-make.exe" `
            -DCMAKE_BUILD_TYPE=Release `
            -DCMAKE_VERBOSE_MAKEFILE=ON
          
          Write-Host "Building BGACore first..."
          cmake --build . --target BGACore --parallel
          if ($LASTEXITCODE -ne 0) {
            Write-Host "BGACore build FAILED"
            Write-Host "Printing build tree for diagnostics..."
            Get-ChildItem -Recurse -Force | Select-Object -First 500 | Format-Table
            exit 1
          }
          
          Write-Host "Verifying BGACore output..."
          $dllPath = "BGA\libBGACore.dll"
          
          if (Test-Path $dllPath) {
            Write-Host "✓ Found libBGACore.dll at: $dllPath"
          } else {
            Write-Host "✗ ERROR: libBGACore.dll not found at: $dllPath"
            Write-Host "Searching for BGACore library files..."
            Get-ChildItem -Path . -Filter "*BGACore*" -Recurse | ForEach-Object { 
              Write-Host "  Found: $($_.FullName)" 
            }
            throw "BGACore library missing after build"
          }
          
          Write-Host "Building remaining targets..."
          cmake --build . --parallel
      
      - name: Verify Build Output
        shell: pwsh
        run: |
          Write-Host "=== Verifying build output ==="
          $exePath = "build\NST.exe"
          
          if (Test-Path $exePath) {
            $size = (Get-Item $exePath).Length
            Write-Host "✓ NST.exe found ($size bytes)"
          } else {
            Write-Host "✗ ERROR: NST.exe not found at: $exePath"
            Write-Host "Searching for NST.exe..."
            Get-ChildItem -Path build -Filter "NST.exe" -Recurse | ForEach-Object { 
              Write-Host "  Found: $($_.FullName)" 
            }
            exit 1
          }
          
          Write-Host ""
          Write-Host "=== Checking DLLs in build folder ==="
          $buildDir = "build"
          $requiredDlls = @("libBGACore.dll", "QtLingo.dll")
          
          foreach ($dll in $requiredDlls) {
            $found = $false
            Get-ChildItem -Path $buildDir -Filter $dll -Recurse | ForEach-Object {
              Write-Host "✓ $dll found at: $($_.FullName)"
              $found = $true
            }
            if (-not $found) {
              Write-Host "⚠ WARNING: $dll not found"
            }
          }
          
          Write-Host ""
          Write-Host "=== All DLLs in build folder ==="
          Get-ChildItem -Path $buildDir -Filter "*.dll" -Recurse | ForEach-Object { 
            $relativePath = $_.FullName.Replace((Get-Location).Path + "\build\", "")
            Write-Host "  $relativePath"
          }

      - name: Deploy Qt dependencies
        shell: pwsh
        run: |
          $exePath = "build\NST.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "✗ ERROR: NST.exe not found at $exePath"
            exit 1
          }

          # Use QT_ROOT_DIR environment variable set by install-qt-action
          $qtBin = Join-Path $env:QT_ROOT_DIR "bin\windeployqt.exe"
          
          if (-not (Test-Path $qtBin)) {
            Write-Host "✗ ERROR: Could not find windeployqt.exe at $qtBin"
            Write-Host "QT_ROOT_DIR: $env:QT_ROOT_DIR"
            exit 1
          }

          Write-Host "Running windeployqt from: $qtBin"
          & $qtBin --release --compiler-runtime --no-opengl-sw $exePath
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "✗ ERROR: windeployqt failed"
            exit 1
          }

          Write-Host "✓ windeployqt completed successfully"
          Write-Host "DLLs deployed to build folder"

      - name: Package
        run: |
          cd build
          cpack -G ZIP -C Release
      
      - name: Verify Package
        shell: pwsh
        run: |
          Write-Host "=== Verifying package ==="
          $packageFile = Get-ChildItem -Path build -Filter "NST-*.zip" | Select-Object -First 1
          
          if ($packageFile) {
            Write-Host "Package: $($packageFile.Name) ($('{0:N2}' -f ($packageFile.Length / 1MB)) MB)"
            
            Write-Host "Extracting to verify contents..."
            $tempDir = "build\temp_verify"
            Expand-Archive -Path $packageFile.FullName -DestinationPath $tempDir -Force
            
            Write-Host ""
            Write-Host "Package contents:"
            Get-ChildItem -Path $tempDir -Recurse | ForEach-Object { 
              $relativePath = $_.FullName.Substring($tempDir.Length)
              $size = if ($_.PSIsContainer) { "DIR" } else { "{0:N0} bytes" -f $_.Length }
              Write-Host "  $relativePath ($size)"
            }
            
            Remove-Item -Path $tempDir -Recurse -Force
          } else {
            Write-Host "✗ ERROR: No package file found"
            exit 1
          }
      
      - name: Find package file
        id: find_files
        shell: bash
        run: |
          cd build
          PACKAGE_FILE=$(ls NST-*.zip 2>/dev/null | head -n 1 || true)
          echo "package_file=$PACKAGE_FILE" >> $GITHUB_OUTPUT
          if [ -n "$PACKAGE_FILE" ]; then
            echo "Found package: $PACKAGE_FILE"
          else
            echo "Error: No package found"
            exit 1
          fi
      
      - name: Upload artifact
        if: steps.find_files.outputs.package_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: nst-windows
          path: build/${{ steps.find_files.outputs.package_file }}
          retention-days: 1

  release-windows:
    needs: build-windows
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows
          path: artifacts
      
      - name: Set version tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "tag=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.version.outputs.tag }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${REPO}"
          
          # Get or create release
          resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${API}/releases/tags/${TAG}" || true)
          release_id=$(echo "$resp" | jq -r '.id // empty')
          
          if [ -z "$release_id" ]; then
            echo "Creating release for ${TAG}"
            create_resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
              -d "$(jq -n --arg t "$TAG" --arg n "Release $TAG" '{ tag_name: $t, name: $n }')" \
              "${API}/releases")
            release_id=$(echo "$create_resp" | jq -r '.id')
          fi
          
          # Upload artifact
          for f in artifacts/*; do
            [ -f "$f" ] || continue
            name=$(basename "$f")
            echo "Uploading $name"
            curl -s -X POST \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Content-Type: application/zip" \
              --data-binary @"$f" \
              "https://uploads.github.com/repos/${REPO}/releases/${release_id}/assets?name=$name"
          done
