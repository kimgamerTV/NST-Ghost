name: Release Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.2)'
        required: true
        type: string

jobs:
  build-windows:
    runs-on: windows-latest
    strategy:
      matrix:
        build_type: [Release, Debug]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install MinGW and Ninja
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-ninja
      
      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.7.3'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw'
          cache: true
          setup-python: false
      
      - name: Configure CMake
        shell: msys2 {0}
        run: |
          mkdir -p build
          cd build
          
          echo "=== CMake Configuration ==="
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Qt Root: ${QT_ROOT_DIR}"
          
          cmake .. -G "Ninja" \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
            -DCMAKE_PREFIX_PATH="${QT_ROOT_DIR}"
      
      - name: Build
        shell: msys2 {0}
        run: |
          cd build
          echo "=== Building NST ==="
          cmake --build . --parallel
          
          echo ""
          echo "=== Build Output ==="
          ls -lh NST.exe BGA/libBGACore.dll QtLingo/libQtLingo.dll
      
      - name: Install (Deploy)
        shell: msys2 {0}
        run: |
          cd build
          echo "=== Installing to staging directory ==="
          
          # Install to a staging directory
          DESTDIR="${PWD}/package" cmake --install . --prefix ""
          
          echo ""
          echo "=== Installed files ==="
          find package -type f | head -50
      
      - name: Package
        shell: msys2 {0}
        run: |
          cd build
          
          echo "=== Creating ZIP package ==="
          cpack -G ZIP -C ${{ matrix.build_type }}
          
          echo ""
          echo "=== Generated package ==="
          ls -lh *.zip
      
      - name: Verify Package
        shell: pwsh
        run: |
          Write-Host "=== Verifying package ===" -ForegroundColor Cyan
          
          $zipFiles = Get-ChildItem -Path build -Filter "*.zip"
          
          if ($zipFiles.Count -eq 0) {
            Write-Host "ERROR: No ZIP files found!" -ForegroundColor Red
            exit 1
          }
          
          foreach ($zip in $zipFiles) {
            Write-Host ""
            Write-Host "Package: $($zip.Name)" -ForegroundColor Green
            Write-Host "Size: $([math]::Round($zip.Length / 1MB, 2)) MB"
            
            # Extract and verify contents
            $tempDir = "build\verify_$($zip.BaseName)"
            Expand-Archive -Path $zip.FullName -DestinationPath $tempDir -Force
            
            Write-Host ""
            Write-Host "Contents:" -ForegroundColor Yellow
            Get-ChildItem -Path $tempDir -Recurse -File | ForEach-Object {
              $relativePath = $_.FullName.Replace($tempDir, "").TrimStart("\")
              Write-Host "  $relativePath"
            }
            
            # Check for essential files
            $requiredFiles = @("bin\NST.exe", "bin\libBGACore.dll", "bin\QtLingo.dll")
            $missing = @()
            
            foreach ($file in $requiredFiles) {
              $fullPath = Join-Path $tempDir $file
              if (-not (Test-Path $fullPath)) {
                $missing += $file
              }
            }
            
            if ($missing.Count -gt 0) {
              Write-Host ""
              Write-Host "WARNING: Missing files:" -ForegroundColor Red
              $missing | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
            } else {
              Write-Host ""
              Write-Host "All essential files present!" -ForegroundColor Green
            }
            
            Remove-Item -Path $tempDir -Recurse -Force
          }
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: nst-windows-${{ matrix.build_type }}
          path: build/*.zip
          retention-days: 1

  release-windows:
    needs: build-windows
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Release artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows-Release
          path: artifacts
      
      - name: Download Debug artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows-Debug
          path: artifacts
      
      - name: Set version tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "tag=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.version.outputs.tag }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${REPO}"
          
          echo "Artifacts to upload:"
          ls -lh artifacts/
          
          # Get or create release
          resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${API}/releases/tags/${TAG}" || true)
          release_id=$(echo "$resp" | jq -r '.id // empty')
          
          if [ -z "$release_id" ]; then
            echo "Creating release for ${TAG}"
            create_resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
              -d "$(jq -n --arg t "$TAG" --arg n "Release $TAG" '{ tag_name: $t, name: $n }')" \
              "${API}/releases")
            release_id=$(echo "$create_resp" | jq -r '.id')
          fi
          
          # Upload artifacts
          for f in artifacts/*; do
            [ -f "$f" ] || continue
            name=$(basename "$f")
            echo "Uploading $name"
            curl -s -X POST \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Content-Type: application/zip" \
              --data-binary @"$f" \
              "https://uploads.github.com/repos/${REPO}/releases/${release_id}/assets?name=$name"
          done
          
          echo "âœ“ Upload completed"
          echo "Release URL: https://github.com/${REPO}/releases/tag/${TAG}"
