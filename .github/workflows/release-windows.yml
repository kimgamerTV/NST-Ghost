name: Release Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.4.3)'
        required: true
        type: string

jobs:
  build-windows:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # use boolean for submodules to avoid schema errors
          submodules: true
          fetch-depth: 0

      - name: Install MinGW and Ninja
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-ninja

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.7.3'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw'
          cache: true
          setup-python: false

      - name: Configure CMake
        shell: msys2 {0}
        run: |
          mkdir -p build
          cd build

          echo "=== CMake Configuration ==="
          echo "Build Type: Release"
          echo "Qt Root: ${QT_ROOT_DIR:-(not set)}"

          # Use absolute path for install prefix
          INSTALL_PREFIX="$(pwd)/install"
          echo "Install prefix: ${INSTALL_PREFIX}"

          cmake .. -G "Ninja" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_PREFIX_PATH="${QT_ROOT_DIR}" \
            -DCMAKE_INSTALL_PREFIX="${INSTALL_PREFIX}"

      - name: Build
        shell: msys2 {0}
        run: |
          cd build
          echo "=== Building NST ==="
          cmake --build . --parallel

          echo ""
          echo "=== Build Output ==="
          echo "Executable:"
          ls -lh NST.exe || echo "NST.exe not found"
          echo ""
          echo "Libraries:"
          ls -lh *.dll || echo "No DLL files in root"
          echo ""
          echo "Searching for DLL files:"
          find . -name "*.dll" -type f | head -20

      - name: Install (Deploy)
        shell: msys2 {0}
        run: |
          cd build
          echo "=== Installing to staging directory ==="

          # Install with the prefix we set in CMake
          cmake --install .

          echo ""
          echo "=== Installed files ==="
          find install -type f | head -50

          echo ""
          echo "=== Checking critical files ==="

          # Check for NST.exe
          if [ -f "install/bin/NST.exe" ]; then
            echo "✓ NST.exe found"
          else
            echo "✗ NST.exe NOT FOUND!"
            exit 1
          fi

          # Check for custom DLLs
          if [ -f "install/bin/libBGACore.dll" ]; then
            echo "✓ libBGACore.dll found"
          else
            echo "✗ libBGACore.dll NOT FOUND!"
            exit 1
          fi

          if [ -f "install/bin/QtLingo.dll" ]; then
            echo "✓ QtLingo.dll found"
          else
            echo "✗ QtLingo.dll NOT FOUND!"
            exit 1
          fi

          # Check for Qt DLLs
          echo ""
          echo "Qt DLLs in bin:"
          ls -lh install/bin/Qt6*.dll 2>/dev/null || echo "No Qt6 DLLs found"

          # Check for plugins
          echo ""
          echo "Plugins directory:"
          if [ -d "install/bin/plugins" ]; then
            echo "✓ plugins directory exists"
            find install/bin/plugins -name "*.dll"
          else
            echo "✗ plugins directory NOT FOUND!"
          fi

          # Check for platform plugin (critical!)
          if [ -f "install/bin/plugins/platforms/qwindows.dll" ]; then
            echo "✓ qwindows.dll (platform plugin) found"
          else
            echo "✗ qwindows.dll (platform plugin) NOT FOUND!"
            echo "This will cause the application to crash!"
          fi

          # Check for qt.conf
          if [ -f "install/bin/qt.conf" ]; then
            echo "✓ qt.conf found"
            echo "Contents:"
            cat install/bin/qt.conf
          else
            echo "⚠ qt.conf NOT FOUND - creating one"
            cat > install/bin/qt.conf << 'EOF'
[Paths]
Plugins = plugins
Prefix = .
EOF
            echo "Created qt.conf with content:"
            cat install/bin/qt.conf
          fi

          # Check for MinGW runtime
          echo ""
          echo "MinGW runtime DLLs:"
          ls -lh install/bin/libgcc*.dll install/bin/libstdc++*.dll install/bin/libwinpthread*.dll 2>/dev/null || echo "Some MinGW DLLs may be missing"

      - name: Package
        shell: msys2 {0}
        run: |
          cd build

          echo "=== Creating ZIP package ==="
          cpack -G ZIP -C Release || true

          echo ""
          echo "=== Generated package ==="
          ls -lh *.zip || echo "No zip generated"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: nst-windows-release
          path: build/*.zip
          retention-days: 1

  release-windows:
    needs: build-windows
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Release artifact
        uses: actions/download-artifact@v4
        with:
          name: nst-windows-release
          path: artifacts

      - name: Determine tag to use
        id: version
        run: |
          # If triggered manually, workflow_dispatch inputs.version will be non-empty
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
            echo "tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            # For push events, github.ref_name contains the tag name
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Upload to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.version.outputs.tag }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${REPO}"

          echo "Artifacts to upload:"
          ls -lh artifacts/ || true

          # Get or create release
          resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${API}/releases/tags/${TAG}" || true)
          release_id=$(echo "$resp" | jq -r '.id // empty')

          if [ -z "$release_id" ]; then
            echo "Creating release for ${TAG}"
            create_resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
              -d "$(jq -n --arg t "$TAG" --arg n "Release $TAG" '{ tag_name: $t, name: $n }')" \
              "${API}/releases")
            release_id=$(echo "$create_resp" | jq -r '.id')
          fi

          # Upload artifacts
          for f in artifacts/*; do
            [ -f "$f" ] || continue
            name=$(basename "$f")
            echo "Uploading $name"
            curl -s -X POST \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Content-Type: application/zip" \
              --data-binary @"$f" \
              "https://uploads.github.com/repos/${REPO}/releases/${release_id}/assets?name=$name"
          done

          echo "✓ Upload completed"
          echo "Release URL: https://github.com/${REPO}/releases/tag/${TAG}"
